# 成本计算器架构 (Cost Calculator Architecture)

## 核心设计思想

为了实现一个灵活、可扩展、支持多目标优化的框架，我们采用了**策略设计模式 (Strategy Design Pattern)**。

该模式的核心是将“做什么”（执行HFSS仿真）与“怎么评估”（如何计算成本）完全分离。

## 主要组件

1.  **`adaptive_optimize.py` (主流程)**
    *   **`evaluate_hfss` 函数 (协调器)**: 此核心函数现在的职责非常纯粹：
        1.  接收一组新的设计参数。
        2.  在HFSS中设置这些参数。
        3.  运行一次HFSS分析 (`hfss.analyze_setup()`)。
        4.  遍历下面定义的 `COST_OBJECTIVES` 列表，将 `hfss` 会话对象传递给每一个策略，并由策略自己完成评估。
        5.  它**不再获取任何具体的数据**，只负责调度。

2.  **`CostCalculator` (抽象基类)**
    *   定义了所有成本计算策略必须遵守的接口规范，主要是 `calculate(self, hfss)` 方法。
    *   包含了一个用于成本归一化的通用 `normalize()` 方法。

3.  **具体的策略类 (例如 `SParameterCost`, `TDRCost`)**
    *   **完全自洽**: 每个策略类都是一个独立的、自洽的单元。
    *   **独立的数据获取**: 每个类的 `calculate(self, hfss)` 方法**内部**负责调用 `hfss.post.get_solution_data()` 来获取**它自己所需要的特定数据**（例如，S参数策略获取频域数据，TDR策略获取时域数据）。
    *   **独立的计算逻辑**: 每个类内部实现其独特的成本计算数学逻辑。

4.  **`COST_OBJECTIVES` (配置文件)**
    *   位于脚本顶部的列表，是用户与框架交互的**唯一入口**。
    *   用户通过编辑此列表，可以像乐高积木一样组合不同的优化目标，并为每个目标分配权重。

## 优势

*   **高扩展性**: 添加一个新的优化目标（如插损、阻抗匹配），只需创建一个新的策略类，而**无需修改任何现有核心代码**。
*   **高内聚，低耦合**: 每个策略的逻辑都封装在自己的类中，与其他策略完全解耦。
*   **清晰的职责分离**: `evaluate_hfss` 只负责“运行”，而策略类负责“评估”，代码结构清晰，易于维护。
